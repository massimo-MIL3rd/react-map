{"ast":null,"code":"import { createContext, useContext, useState, useCallback, createElement, useMemo } from 'react';\nimport { useForceUpdate } from '@reach/utils/use-force-update';\nimport { useIsomorphicLayoutEffect } from '@reach/utils/use-isomorphic-layout-effect';\nimport { noop } from '@reach/utils/noop';\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nvar _excluded = [\"element\", \"index\"];\n\nfunction createDescendantContext(name, initialValue) {\n  if (initialValue === void 0) {\n    initialValue = {};\n  }\n\n  var descendants = [];\n  var ctx = /*#__PURE__*/createContext(_extends({\n    descendants: descendants,\n    registerDescendant: noop,\n    unregisterDescendant: noop\n  }, initialValue));\n\n  if (process.env.NODE_ENV !== \"production\") {\n    ctx.displayName = name;\n  }\n\n  return ctx;\n}\n/**\n * This hook registers our descendant by passing it into an array. We can then\n * search that array by to find its index when registering it in the component.\n * We use this for focus management, keyboard navigation, and typeahead\n * functionality for some components.\n *\n * The hook accepts the element node and (optionally) a key. The key is useful\n * if multiple descendants have identical text values and we need to\n * differentiate siblings for some reason.\n *\n * Our main goals with this are:\n *   1) maximum composability,\n *   2) minimal API friction\n *   3) SSR compatibility*\n *   4) concurrent safe\n *   5) index always up-to-date with the tree despite changes\n *   6) works with memoization of any component in the tree (hopefully)\n *\n * As for SSR, the good news is that we don't actually need the index on the\n * server for most use-cases, as we are only using it to determine the order of\n * composed descendants for keyboard navigation. However, in the few cases where\n * this is not the case, we can require an explicit index from the app.\n */\n\n\nfunction useDescendant(descendant, context, indexProp) {\n  var forceUpdate = useForceUpdate();\n\n  var _React$useContext = useContext(context),\n      registerDescendant = _React$useContext.registerDescendant,\n      unregisterDescendant = _React$useContext.unregisterDescendant,\n      descendants = _React$useContext.descendants; // This will initially return -1 because we haven't registered the descendant\n  // on the first render. After we register, this will then return the correct\n  // index on the following render and we will re-register descendants so that\n  // everything is up-to-date before the user interacts with a collection.\n\n\n  var index = indexProp != null ? indexProp : descendants.findIndex(function (item) {\n    return item.element === descendant.element;\n  }); // Prevent any flashing\n\n  useIsomorphicLayoutEffect(function () {\n    if (!descendant.element) forceUpdate();\n    registerDescendant(_extends({}, descendant, {\n      index: index\n    }));\n    return function () {\n      unregisterDescendant(descendant.element);\n    };\n  }, [descendant, forceUpdate, index, registerDescendant, unregisterDescendant].concat(Object.values(descendant)));\n  return index;\n}\n\nfunction useDescendantsInit() {\n  return useState([]);\n}\n\nfunction useDescendants(ctx) {\n  return useContext(ctx).descendants;\n}\n\nfunction DescendantProvider(_ref) {\n  var Ctx = _ref.context,\n      children = _ref.children,\n      items = _ref.items,\n      set = _ref.set;\n  var registerDescendant = useCallback(function (_ref2) {\n    var element = _ref2.element,\n        explicitIndex = _ref2.index,\n        rest = _objectWithoutPropertiesLoose(_ref2, _excluded);\n\n    if (!element) {\n      return;\n    }\n\n    set(function (items) {\n      var newItems;\n\n      if (explicitIndex != null) {\n        return [].concat(items, [_extends({}, rest, {\n          element: element,\n          index: explicitIndex\n        })]).sort(function (a, b) {\n          return a.index - b.index;\n        });\n      } else if (items.length === 0) {\n        // If there are no items, register at index 0 and bail.\n        newItems = [_extends({}, rest, {\n          element: element,\n          index: 0\n        })];\n      } else if (items.find(function (item) {\n        return item.element === element;\n      })) {\n        // If the element is already registered, just use the same array\n        newItems = items;\n      } else {\n        // When registering a descendant, we need to make sure we insert in\n        // into the array in the same order that it appears in the DOM. So as\n        // new descendants are added or maybe some are removed, we always know\n        // that the array is up-to-date and correct.\n        //\n        // So here we look at our registered descendants and see if the new\n        // element we are adding appears earlier than an existing descendant's\n        // DOM node via `node.compareDocumentPosition`. If it does, we insert\n        // the new element at this index. Because `registerDescendant` will be\n        // called in an effect every time the descendants state value changes,\n        // we should be sure that this index is accurate when descendent\n        // elements come or go from our component.\n        var index = items.findIndex(function (item) {\n          if (!item.element || !element) {\n            return false;\n          } // Does this element's DOM node appear before another item in the\n          // array in our DOM tree? If so, return true to grab the index at\n          // this point in the array so we know where to insert the new\n          // element.\n\n\n          return Boolean(item.element.compareDocumentPosition(element) & Node.DOCUMENT_POSITION_PRECEDING);\n        });\n\n        var newItem = _extends({}, rest, {\n          element: element,\n          index: index\n        }); // If an index is not found we will push the element to the end.\n\n\n        if (index === -1) {\n          newItems = [].concat(items, [newItem]);\n        } else {\n          newItems = [].concat(items.slice(0, index), [newItem], items.slice(index));\n        }\n      }\n\n      return newItems.map(function (item, index) {\n        return _extends({}, item, {\n          index: index\n        });\n      });\n    });\n  }, // set is a state setter initialized by the useDescendantsInit hook.\n  // We can safely ignore the lint warning here because it will not change\n  // between renders.\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  []);\n  var unregisterDescendant = useCallback(function (element) {\n    if (!element) {\n      return;\n    }\n\n    set(function (items) {\n      return items.filter(function (item) {\n        return element !== item.element;\n      });\n    });\n  }, // set is a state setter initialized by the useDescendantsInit hook.\n  // We can safely ignore the lint warning here because it will not change\n  // between renders.\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  []);\n  return /*#__PURE__*/createElement(Ctx.Provider, {\n    value: useMemo(function () {\n      return {\n        descendants: items,\n        registerDescendant: registerDescendant,\n        unregisterDescendant: unregisterDescendant\n      };\n    }, [items, registerDescendant, unregisterDescendant])\n  }, children);\n}\n/**\n * Testing this as an abstraction for compound components that use keyboard\n * navigation. Hoping this will help us prevent bugs and mismatched behavior\n * across various components, but it may also prove to be too messy of an\n * abstraction in the end.\n *\n * Currently used in:\n *   - Tabs\n *   - Accordion\n *\n * @param context\n * @param options\n */\n\n\nfunction useDescendantKeyDown(context, options) {\n  var _React$useContext2 = useContext(context),\n      descendants = _React$useContext2.descendants;\n\n  var callback = options.callback,\n      currentIndex = options.currentIndex,\n      filter = options.filter,\n      _options$key = options.key,\n      key = _options$key === void 0 ? \"index\" : _options$key,\n      _options$orientation = options.orientation,\n      orientation = _options$orientation === void 0 ? \"vertical\" : _options$orientation,\n      _options$rotate = options.rotate,\n      rotate = _options$rotate === void 0 ? true : _options$rotate,\n      _options$rtl = options.rtl,\n      rtl = _options$rtl === void 0 ? false : _options$rtl;\n  return function handleKeyDown(event) {\n    if (![\"ArrowDown\", \"ArrowUp\", \"ArrowLeft\", \"ArrowRight\", \"PageUp\", \"PageDown\", \"Home\", \"End\"].includes(event.key)) {\n      return;\n    }\n\n    var index = currentIndex != null ? currentIndex : -1; // If we use a filter function, we need to re-index our descendants array\n    // so that filtered descendent elements aren't selected.\n\n    var selectableDescendants = filter ? descendants.filter(filter) : descendants; // We need some options for any of this to work!\n\n    if (!selectableDescendants.length) {\n      return;\n    }\n\n    var selectableIndex = selectableDescendants.findIndex(function (descendant) {\n      return descendant.index === currentIndex;\n    });\n\n    function getNextOption() {\n      var atBottom = index === getLastOption().index;\n      return atBottom ? rotate ? getFirstOption() : selectableDescendants[selectableIndex] : selectableDescendants[(selectableIndex + 1) % selectableDescendants.length];\n    }\n\n    function getPreviousOption() {\n      var atTop = index === getFirstOption().index;\n      return atTop ? rotate ? getLastOption() : selectableDescendants[selectableIndex] : selectableDescendants[(selectableIndex - 1 + selectableDescendants.length) % selectableDescendants.length];\n    }\n\n    function getFirstOption() {\n      return selectableDescendants[0];\n    }\n\n    function getLastOption() {\n      return selectableDescendants[selectableDescendants.length - 1];\n    }\n\n    switch (event.key) {\n      case \"ArrowDown\":\n        if (orientation === \"vertical\" || orientation === \"both\") {\n          event.preventDefault();\n          var next = getNextOption();\n          callback(key === \"option\" ? next : next[key]);\n        }\n\n        break;\n\n      case \"ArrowUp\":\n        if (orientation === \"vertical\" || orientation === \"both\") {\n          event.preventDefault();\n          var prev = getPreviousOption();\n          callback(key === \"option\" ? prev : prev[key]);\n        }\n\n        break;\n\n      case \"ArrowLeft\":\n        if (orientation === \"horizontal\" || orientation === \"both\") {\n          event.preventDefault();\n          var nextOrPrev = (rtl ? getNextOption : getPreviousOption)();\n          callback(key === \"option\" ? nextOrPrev : nextOrPrev[key]);\n        }\n\n        break;\n\n      case \"ArrowRight\":\n        if (orientation === \"horizontal\" || orientation === \"both\") {\n          event.preventDefault();\n          var prevOrNext = (rtl ? getPreviousOption : getNextOption)();\n          callback(key === \"option\" ? prevOrNext : prevOrNext[key]);\n        }\n\n        break;\n\n      case \"PageUp\":\n        event.preventDefault();\n        var prevOrFirst = (event.ctrlKey ? getPreviousOption : getFirstOption)();\n        callback(key === \"option\" ? prevOrFirst : prevOrFirst[key]);\n        break;\n\n      case \"Home\":\n        event.preventDefault();\n        var first = getFirstOption();\n        callback(key === \"option\" ? first : first[key]);\n        break;\n\n      case \"PageDown\":\n        event.preventDefault();\n        var nextOrLast = (event.ctrlKey ? getNextOption : getLastOption)();\n        callback(key === \"option\" ? nextOrLast : nextOrLast[key]);\n        break;\n\n      case \"End\":\n        event.preventDefault();\n        var last = getLastOption();\n        callback(key === \"option\" ? last : last[key]);\n        break;\n    }\n  };\n} ////////////////////////////////////////////////////////////////////////////////\n\n\nexport { DescendantProvider, createDescendantContext, useDescendant, useDescendantKeyDown, useDescendants, useDescendantsInit };","map":{"version":3,"names":["createContext","useContext","useState","useCallback","createElement","useMemo","useForceUpdate","useIsomorphicLayoutEffect","noop","_objectWithoutPropertiesLoose","source","excluded","target","sourceKeys","Object","keys","key","i","length","indexOf","_extends","assign","arguments","prototype","hasOwnProperty","call","apply","_excluded","createDescendantContext","name","initialValue","descendants","ctx","registerDescendant","unregisterDescendant","process","env","NODE_ENV","displayName","useDescendant","descendant","context","indexProp","forceUpdate","_React$useContext","index","findIndex","item","element","concat","values","useDescendantsInit","useDescendants","DescendantProvider","_ref","Ctx","children","items","set","_ref2","explicitIndex","rest","newItems","sort","a","b","find","Boolean","compareDocumentPosition","Node","DOCUMENT_POSITION_PRECEDING","newItem","slice","map","filter","Provider","value","useDescendantKeyDown","options","_React$useContext2","callback","currentIndex","_options$key","_options$orientation","orientation","_options$rotate","rotate","_options$rtl","rtl","handleKeyDown","event","includes","selectableDescendants","selectableIndex","getNextOption","atBottom","getLastOption","getFirstOption","getPreviousOption","atTop","preventDefault","next","prev","nextOrPrev","prevOrNext","prevOrFirst","ctrlKey","first","nextOrLast","last"],"sources":["/Users/kawakamimasao/Desktop/react-map/node_modules/@reach/descendants/dist/reach-descendants.esm.js"],"sourcesContent":["import { createContext, useContext, useState, useCallback, createElement, useMemo } from 'react';\nimport { useForceUpdate } from '@reach/utils/use-force-update';\nimport { useIsomorphicLayoutEffect } from '@reach/utils/use-isomorphic-layout-effect';\nimport { noop } from '@reach/utils/noop';\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nvar _excluded = [\"element\", \"index\"];\n\nfunction createDescendantContext(name, initialValue) {\n  if (initialValue === void 0) {\n    initialValue = {};\n  }\n\n  var descendants = [];\n  var ctx = /*#__PURE__*/createContext(_extends({\n    descendants: descendants,\n    registerDescendant: noop,\n    unregisterDescendant: noop\n  }, initialValue));\n\n  if (process.env.NODE_ENV !== \"production\") {\n    ctx.displayName = name;\n  }\n\n  return ctx;\n}\n/**\n * This hook registers our descendant by passing it into an array. We can then\n * search that array by to find its index when registering it in the component.\n * We use this for focus management, keyboard navigation, and typeahead\n * functionality for some components.\n *\n * The hook accepts the element node and (optionally) a key. The key is useful\n * if multiple descendants have identical text values and we need to\n * differentiate siblings for some reason.\n *\n * Our main goals with this are:\n *   1) maximum composability,\n *   2) minimal API friction\n *   3) SSR compatibility*\n *   4) concurrent safe\n *   5) index always up-to-date with the tree despite changes\n *   6) works with memoization of any component in the tree (hopefully)\n *\n * As for SSR, the good news is that we don't actually need the index on the\n * server for most use-cases, as we are only using it to determine the order of\n * composed descendants for keyboard navigation. However, in the few cases where\n * this is not the case, we can require an explicit index from the app.\n */\n\n\nfunction useDescendant(descendant, context, indexProp) {\n  var forceUpdate = useForceUpdate();\n\n  var _React$useContext = useContext(context),\n      registerDescendant = _React$useContext.registerDescendant,\n      unregisterDescendant = _React$useContext.unregisterDescendant,\n      descendants = _React$useContext.descendants; // This will initially return -1 because we haven't registered the descendant\n  // on the first render. After we register, this will then return the correct\n  // index on the following render and we will re-register descendants so that\n  // everything is up-to-date before the user interacts with a collection.\n\n\n  var index = indexProp != null ? indexProp : descendants.findIndex(function (item) {\n    return item.element === descendant.element;\n  }); // Prevent any flashing\n\n  useIsomorphicLayoutEffect(function () {\n    if (!descendant.element) forceUpdate();\n    registerDescendant(_extends({}, descendant, {\n      index: index\n    }));\n    return function () {\n      unregisterDescendant(descendant.element);\n    };\n  }, [descendant, forceUpdate, index, registerDescendant, unregisterDescendant].concat(Object.values(descendant)));\n  return index;\n}\n\nfunction useDescendantsInit() {\n  return useState([]);\n}\n\nfunction useDescendants(ctx) {\n  return useContext(ctx).descendants;\n}\n\nfunction DescendantProvider(_ref) {\n  var Ctx = _ref.context,\n      children = _ref.children,\n      items = _ref.items,\n      set = _ref.set;\n  var registerDescendant = useCallback(function (_ref2) {\n    var element = _ref2.element,\n        explicitIndex = _ref2.index,\n        rest = _objectWithoutPropertiesLoose(_ref2, _excluded);\n\n    if (!element) {\n      return;\n    }\n\n    set(function (items) {\n      var newItems;\n\n      if (explicitIndex != null) {\n        return [].concat(items, [_extends({}, rest, {\n          element: element,\n          index: explicitIndex\n        })]).sort(function (a, b) {\n          return a.index - b.index;\n        });\n      } else if (items.length === 0) {\n        // If there are no items, register at index 0 and bail.\n        newItems = [_extends({}, rest, {\n          element: element,\n          index: 0\n        })];\n      } else if (items.find(function (item) {\n        return item.element === element;\n      })) {\n        // If the element is already registered, just use the same array\n        newItems = items;\n      } else {\n        // When registering a descendant, we need to make sure we insert in\n        // into the array in the same order that it appears in the DOM. So as\n        // new descendants are added or maybe some are removed, we always know\n        // that the array is up-to-date and correct.\n        //\n        // So here we look at our registered descendants and see if the new\n        // element we are adding appears earlier than an existing descendant's\n        // DOM node via `node.compareDocumentPosition`. If it does, we insert\n        // the new element at this index. Because `registerDescendant` will be\n        // called in an effect every time the descendants state value changes,\n        // we should be sure that this index is accurate when descendent\n        // elements come or go from our component.\n        var index = items.findIndex(function (item) {\n          if (!item.element || !element) {\n            return false;\n          } // Does this element's DOM node appear before another item in the\n          // array in our DOM tree? If so, return true to grab the index at\n          // this point in the array so we know where to insert the new\n          // element.\n\n\n          return Boolean(item.element.compareDocumentPosition(element) & Node.DOCUMENT_POSITION_PRECEDING);\n        });\n\n        var newItem = _extends({}, rest, {\n          element: element,\n          index: index\n        }); // If an index is not found we will push the element to the end.\n\n\n        if (index === -1) {\n          newItems = [].concat(items, [newItem]);\n        } else {\n          newItems = [].concat(items.slice(0, index), [newItem], items.slice(index));\n        }\n      }\n\n      return newItems.map(function (item, index) {\n        return _extends({}, item, {\n          index: index\n        });\n      });\n    });\n  }, // set is a state setter initialized by the useDescendantsInit hook.\n  // We can safely ignore the lint warning here because it will not change\n  // between renders.\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  []);\n  var unregisterDescendant = useCallback(function (element) {\n    if (!element) {\n      return;\n    }\n\n    set(function (items) {\n      return items.filter(function (item) {\n        return element !== item.element;\n      });\n    });\n  }, // set is a state setter initialized by the useDescendantsInit hook.\n  // We can safely ignore the lint warning here because it will not change\n  // between renders.\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  []);\n  return /*#__PURE__*/createElement(Ctx.Provider, {\n    value: useMemo(function () {\n      return {\n        descendants: items,\n        registerDescendant: registerDescendant,\n        unregisterDescendant: unregisterDescendant\n      };\n    }, [items, registerDescendant, unregisterDescendant])\n  }, children);\n}\n/**\n * Testing this as an abstraction for compound components that use keyboard\n * navigation. Hoping this will help us prevent bugs and mismatched behavior\n * across various components, but it may also prove to be too messy of an\n * abstraction in the end.\n *\n * Currently used in:\n *   - Tabs\n *   - Accordion\n *\n * @param context\n * @param options\n */\n\n\nfunction useDescendantKeyDown(context, options) {\n  var _React$useContext2 = useContext(context),\n      descendants = _React$useContext2.descendants;\n\n  var callback = options.callback,\n      currentIndex = options.currentIndex,\n      filter = options.filter,\n      _options$key = options.key,\n      key = _options$key === void 0 ? \"index\" : _options$key,\n      _options$orientation = options.orientation,\n      orientation = _options$orientation === void 0 ? \"vertical\" : _options$orientation,\n      _options$rotate = options.rotate,\n      rotate = _options$rotate === void 0 ? true : _options$rotate,\n      _options$rtl = options.rtl,\n      rtl = _options$rtl === void 0 ? false : _options$rtl;\n  return function handleKeyDown(event) {\n    if (![\"ArrowDown\", \"ArrowUp\", \"ArrowLeft\", \"ArrowRight\", \"PageUp\", \"PageDown\", \"Home\", \"End\"].includes(event.key)) {\n      return;\n    }\n\n    var index = currentIndex != null ? currentIndex : -1; // If we use a filter function, we need to re-index our descendants array\n    // so that filtered descendent elements aren't selected.\n\n    var selectableDescendants = filter ? descendants.filter(filter) : descendants; // We need some options for any of this to work!\n\n    if (!selectableDescendants.length) {\n      return;\n    }\n\n    var selectableIndex = selectableDescendants.findIndex(function (descendant) {\n      return descendant.index === currentIndex;\n    });\n\n    function getNextOption() {\n      var atBottom = index === getLastOption().index;\n      return atBottom ? rotate ? getFirstOption() : selectableDescendants[selectableIndex] : selectableDescendants[(selectableIndex + 1) % selectableDescendants.length];\n    }\n\n    function getPreviousOption() {\n      var atTop = index === getFirstOption().index;\n      return atTop ? rotate ? getLastOption() : selectableDescendants[selectableIndex] : selectableDescendants[(selectableIndex - 1 + selectableDescendants.length) % selectableDescendants.length];\n    }\n\n    function getFirstOption() {\n      return selectableDescendants[0];\n    }\n\n    function getLastOption() {\n      return selectableDescendants[selectableDescendants.length - 1];\n    }\n\n    switch (event.key) {\n      case \"ArrowDown\":\n        if (orientation === \"vertical\" || orientation === \"both\") {\n          event.preventDefault();\n          var next = getNextOption();\n          callback(key === \"option\" ? next : next[key]);\n        }\n\n        break;\n\n      case \"ArrowUp\":\n        if (orientation === \"vertical\" || orientation === \"both\") {\n          event.preventDefault();\n          var prev = getPreviousOption();\n          callback(key === \"option\" ? prev : prev[key]);\n        }\n\n        break;\n\n      case \"ArrowLeft\":\n        if (orientation === \"horizontal\" || orientation === \"both\") {\n          event.preventDefault();\n          var nextOrPrev = (rtl ? getNextOption : getPreviousOption)();\n          callback(key === \"option\" ? nextOrPrev : nextOrPrev[key]);\n        }\n\n        break;\n\n      case \"ArrowRight\":\n        if (orientation === \"horizontal\" || orientation === \"both\") {\n          event.preventDefault();\n          var prevOrNext = (rtl ? getPreviousOption : getNextOption)();\n          callback(key === \"option\" ? prevOrNext : prevOrNext[key]);\n        }\n\n        break;\n\n      case \"PageUp\":\n        event.preventDefault();\n        var prevOrFirst = (event.ctrlKey ? getPreviousOption : getFirstOption)();\n        callback(key === \"option\" ? prevOrFirst : prevOrFirst[key]);\n        break;\n\n      case \"Home\":\n        event.preventDefault();\n        var first = getFirstOption();\n        callback(key === \"option\" ? first : first[key]);\n        break;\n\n      case \"PageDown\":\n        event.preventDefault();\n        var nextOrLast = (event.ctrlKey ? getNextOption : getLastOption)();\n        callback(key === \"option\" ? nextOrLast : nextOrLast[key]);\n        break;\n\n      case \"End\":\n        event.preventDefault();\n        var last = getLastOption();\n        callback(key === \"option\" ? last : last[key]);\n        break;\n    }\n  };\n} ////////////////////////////////////////////////////////////////////////////////\n\nexport { DescendantProvider, createDescendantContext, useDescendant, useDescendantKeyDown, useDescendants, useDescendantsInit };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}